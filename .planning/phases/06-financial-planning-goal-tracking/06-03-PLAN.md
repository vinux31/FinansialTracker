---
phase: 06-financial-planning-goal-tracking
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/app/(dashboard)/goals/timeline/page.tsx
  - src/components/goals/timeline-view.tsx
  - src/components/goals/progress-modal.tsx
  - src/lib/goals/calculations.ts
  - src/lib/goals/status.ts
  - src/components/navigation.tsx
autonomous: true

must_haves:
  truths:
    - User can view monthly timeline showing goals and cashflow projections
    - User can log monthly progress (planned vs actual) for each goal
    - Goal status auto-updates based on deadline and progress
  artifacts:
    - path: src/app/(dashboard)/goals/timeline/page.tsx
      provides: Timeline page showing monthly breakdown
      min_lines: 40
    - path: src/lib/goals/calculations.ts
      provides: Cashflow aggregation utilities
      exports: ["calculateGoalProgress", "calculateSavingsRate"]
    - path: src/lib/goals/status.ts
      provides: Status inference logic
      exports: ["inferGoalStatus", "getGoalStatus"]
  key_links:
    - from: src/components/goals/timeline-view.tsx
      to: lib/goals/calculations
      via: useMemo data aggregation
      pattern: "useMemo.*calculateGoalProgress"
    - from: src/lib/goals/status.ts
      to: date-fns
      via: deadline comparison
      pattern: "isBefore.*parseISO"
---

<objective>
Build timeline visualization and progress tracking system with monthly cashflow calculations and auto-status inference.

Purpose: Enable users to view goal timelines, track monthly progress, and monitor goal status based on deadlines.
Output: Timeline page with monthly table view, progress logging modal, and calculation utilities.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-financial-planning-goal-tracking/06-CONTEXT.md
@.planning/phases/06-financial-planning-goal-tracking/06-RESEARCH.md
@.planning/phases/06-financial-planning-goal-tracking/06-01-SUMMARY.md

Existing calculation patterns:
@src/lib/chart-data.ts
@src/lib/money.ts
@src/lib/date.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create goal calculation utilities with useMemo pattern</name>
  <files>src/lib/goals/calculations.ts</files>
  <action>
Create calculation utilities following chart-data.ts aggregateByMonth pattern:

```typescript
import currency from 'currency.js'
import type { Goal, ProgressEntry } from '@/types'

/**
 * Calculate total saved amount for a goal from progress entries
 */
export function calculateGoalProgress(
  goal: Goal,
  progressEntries: ProgressEntry[]
): {
  totalSaved: number
  percentComplete: number
  monthsRemaining: number
} {
  const entries = progressEntries.filter(e => e.goal_id === goal.id)

  // Sum all actual amounts
  let totalSaved = 0
  for (const entry of entries) {
    totalSaved = currency(totalSaved).add(entry.actual_amount).intValue
  }

  // Calculate percentage
  const percentComplete = goal.target_amount > 0
    ? Math.min(100, Math.round((totalSaved / goal.target_amount) * 100))
    : 0

  // Calculate months remaining
  const deadlineDate = new Date(goal.deadline)
  const today = new Date()
  const monthsRemaining = Math.max(0, Math.ceil((deadlineDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24 * 30)))

  return { totalSaved, percentComplete, monthsRemaining }
}

/**
 * Calculate overall savings rate from goals and income
 */
export function calculateSavingsRate(
  goals: Goal[],
  progressEntries: ProgressEntry[],
  monthlyIncome: number
): number {
  if (monthlyIncome === 0) return 0

  // Sum all planned amounts for current month
  const currentMonth = new Date().toISOString().substring(0, 7) // YYYY-MM
  const monthEntries = progressEntries.filter(e => e.month === currentMonth)

  let totalPlanned = 0
  for (const entry of monthEntries) {
    totalPlanned = currency(totalPlanned).add(entry.planned_amount).intValue
  }

  return monthlyIncome > 0
    ? Math.round((totalPlanned / monthlyIncome) * 100)
    : 0
}

/**
 * Generate monthly timeline data structure
 */
export function buildMonthlyTimeline(
  goals: Goal[],
  progressEntries: ProgressEntry[],
  monthCount: number = 12
): Array<{
  month: string // YYYY-MM
  goals: Goal[] // Goals with deadline in this month
  plannedSavings: number
  actualSavings: number
}> {
  const timeline: Record<string, {
    month: string
    goals: Goal[]
    plannedSavings: number
    actualSavings: number
  }> = {}

  // Initialize months from today forward
  const today = new Date()
  for (let i = 0; i < monthCount; i++) {
    const date = new Date(today.getFullYear(), today.getMonth() + i, 1)
    const monthStr = date.toISOString().substring(0, 7)
    timeline[monthStr] = {
      month: monthStr,
      goals: [],
      plannedSavings: 0,
      actualSavings: 0,
    }
  }

  // Map goals to deadline months
  for (const goal of goals) {
    const goalMonth = goal.deadline.substring(0, 7) // Extract YYYY-MM
    if (timeline[goalMonth]) {
      timeline[goalMonth].goals.push(goal)
    }
  }

  // Aggregate progress entries
  for (const entry of progressEntries) {
    if (timeline[entry.month]) {
      timeline[entry.month].plannedSavings = currency(timeline[entry.month].plannedSavings)
        .add(entry.planned_amount)
        .intValue
      timeline[entry.month].actualSavings = currency(timeline[entry.month].actualSavings)
        .add(entry.actual_amount)
        .intValue
    }
  }

  return Object.values(timeline).sort((a, b) => a.month.localeCompare(b.month))
}
```

Use currency.js for all monetary calculations to prevent floating-point errors. Follow existing aggregateByMonth pattern from chart-data.ts.
  </action>
  <verify>
grep "export function calculateGoalProgress" src/lib/goals/calculations.ts
grep "export function calculateSavingsRate" src/lib/goals/calculations.ts
grep "export function buildMonthlyTimeline" src/lib/goals/calculations.ts
grep "currency.js" src/lib/goals/calculations.ts
  </verify>
  <done>calculations.ts exports calculateGoalProgress, calculateSavingsRate, buildMonthlyTimeline using currency.js for precision and matching existing aggregation patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Create status inference logic with date-fns</name>
  <files>src/lib/goals/status.ts</files>
  <action>
Create status inference module using date-fns for timezone-aware comparisons:

```typescript
import { isBefore, isToday, parseISO } from 'date-fns'
import { TZDate } from '@date-fns/tz'
import type { Goal, ProgressEntry } from '@/types'

const TIMEZONE = 'Asia/Jakarta'

export type GoalStatus = 'upcoming' | 'in-progress' | 'completed' | 'overdue'

/**
 * Infer goal status from deadline and progress data
 */
export function inferGoalStatus(
  goal: Goal,
  totalSavedAmount: number
): GoalStatus {
  const today = new TZDate(new Date(), TIMEZONE)
  const deadline = parseISO(goal.deadline)

  // Completed takes priority
  if (totalSavedAmount >= goal.target_amount) {
    return 'completed'
  }

  // Check if deadline passed
  const isDeadlinePassed = isBefore(deadline, today) && !isToday(deadline)
  if (isDeadlinePassed) {
    return 'overdue'
  }

  // In future: upcoming if no progress, in-progress if started saving
  return totalSavedAmount > 0 ? 'in-progress' : 'upcoming'
}

/**
 * Get goal status with user override support
 */
export function getGoalStatus(
  goal: Goal,
  totalSavedAmount: number
): GoalStatus {
  // User override takes precedence
  if (goal.status_override) {
    return goal.status_override as GoalStatus
  }

  // Otherwise, infer from data
  return inferGoalStatus(goal, totalSavedAmount)
}

/**
 * Calculate timeline adherence risk level
 */
export function getTimelineRisk(
  goal: Goal,
  totalSavedAmount: number
): 'LOW' | 'MEDIUM' | 'HIGH' {
  const { target_amount, deadline } = goal
  const today = new TZDate(new Date(), TIMEZONE)
  const deadlineDate = parseISO(deadline)

  // Months remaining
  const monthsRemaining = Math.max(0, Math.ceil((deadlineDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24 * 30)))

  // Progress percentage
  const progressPercent = target_amount > 0
    ? (totalSavedAmount / target_amount) * 100
    : 0

  // Expected progress if saving evenly
  const totalMonths = Math.max(1, Math.ceil((deadlineDate.getTime() - new Date(goal.created_at).getTime()) / (1000 * 60 * 60 * 24 * 30)))
  const elapsedMonths = totalMonths - monthsRemaining
  const expectedProgress = totalMonths > 0
    ? (elapsedMonths / totalMonths) * 100
    : 0

  // Risk determination
  if (progressPercent >= expectedProgress * 0.9) {
    return 'LOW' // On track or ahead
  } else if (progressPercent >= expectedProgress * 0.6) {
    return 'MEDIUM' // Somewhat behind
  } else {
    return 'HIGH' // Significantly behind
  }
}
```

Use date-fns with Asia/Jakarta timezone (matching existing date.ts pattern). Implement hybrid status approach from user requirements: auto-infer unless override set.
  </action>
  <verify>
grep "export function inferGoalStatus" src/lib/goals/status.ts
grep "export function getGoalStatus" src/lib/goals/status.ts
grep "export function getTimelineRisk" src/lib/goals/status.ts
grep "TZDate.*Asia/Jakarta" src/lib/goals/status.ts
  </verify>
  <done>status.ts exports inferGoalStatus, getGoalStatus (with override support), getTimelineRisk using date-fns with Asia/Jakarta timezone for deadline comparisons.</done>
</task>

<task type="auto">
  <name>Task 3: Create timeline view and progress modal components</name>
  <files>src/components/goals/timeline-view.tsx, src/components/goals/progress-modal.tsx</files>
  <action>
**Create timeline-view.tsx:**
```typescript
'use client'

import { useMemo } from 'react'
import { buildMonthlyTimeline } from '@/lib/goals/calculations'
import { IDR } from '@/lib/money'
import type { Goal, ProgressEntry } from '@/types'

interface TimelineViewProps {
  goals: Goal[]
  progressEntries: ProgressEntry[]
}

export function TimelineView({ goals, progressEntries }: TimelineViewProps) {
  const timeline = useMemo(() => {
    return buildMonthlyTimeline(goals, progressEntries, 12)
  }, [goals, progressEntries])

  return (
    <div className="overflow-x-auto">
      <table className="w-full border-collapse text-sm">
        <thead>
          <tr className="border-b bg-gray-50">
            <th className="px-4 py-2 text-left font-semibold">Month</th>
            <th className="px-4 py-2 text-right font-semibold">Planned Savings</th>
            <th className="px-4 py-2 text-right font-semibold">Actual Savings</th>
            <th className="px-4 py-2 text-left font-semibold">Goal Events</th>
          </tr>
        </thead>
        <tbody>
          {timeline.map(month => (
            <tr key={month.month} className="border-b hover:bg-gray-50">
              <td className="px-4 py-3 font-medium">
                {new Date(month.month + '-01').toLocaleDateString('id-ID', {
                  year: 'numeric',
                  month: 'long'
                })}
              </td>
              <td className="px-4 py-3 text-right text-gray-700">
                {IDR(month.plannedSavings)}
              </td>
              <td className="px-4 py-3 text-right">
                <span className={
                  month.actualSavings >= month.plannedSavings
                    ? 'text-green-700 font-medium'
                    : 'text-red-700'
                }>
                  {IDR(month.actualSavings)}
                </span>
              </td>
              <td className="px-4 py-3">
                {month.goals.length > 0 ? (
                  <div className="space-y-1">
                    {month.goals.map(goal => (
                      <div key={goal.id} className="text-xs">
                        <span className="font-semibold">{goal.name}</span>
                        <span className="text-gray-600 ml-2">{IDR(goal.target_amount)}</span>
                      </div>
                    ))}
                  </div>
                ) : (
                  <span className="text-gray-400">â€”</span>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}
```

**Create progress-modal.tsx:**
```typescript
'use client'

import { useRef, useState } from 'react'
import { upsertGoalProgress } from '@/lib/db'
import type { Goal } from '@/types'

interface ProgressModalProps {
  goal: Goal
  month: string // YYYY-MM
  onClose: () => void
  onSuccess: () => void
}

export function ProgressModal({ goal, month, onClose, onSuccess }: ProgressModalProps) {
  const formRef = useRef<HTMLFormElement>(null)
  const [loading, setLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)

    try {
      const formData = new FormData(e.currentTarget as HTMLFormElement)
      await upsertGoalProgress({
        goal_id: goal.id,
        month: month,
        planned_amount: parseInt(formData.get('planned_amount') as string),
        actual_amount: parseInt(formData.get('actual_amount') as string),
        notes: formData.get('notes') as string || '',
      })
      onSuccess()
      onClose()
    } catch (err) {
      alert('Failed to save progress')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
        <h2 className="text-xl font-semibold mb-4">
          Log Progress: {goal.name}
        </h2>
        <p className="text-sm text-gray-600 mb-4">
          Month: {new Date(month + '-01').toLocaleDateString('id-ID', { year: 'numeric', month: 'long' })}
        </p>

        <form ref={formRef} onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">
              Planned Amount (IDR)
            </label>
            <input
              type="number"
              name="planned_amount"
              placeholder="5000000"
              required
              min="0"
              step="1"
              className="w-full px-3 py-2 border rounded-md"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">
              Actual Amount (IDR)
            </label>
            <input
              type="number"
              name="actual_amount"
              placeholder="4500000"
              required
              min="0"
              step="1"
              className="w-full px-3 py-2 border rounded-md"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">
              Notes (optional)
            </label>
            <textarea
              name="notes"
              placeholder="e.g., Saved less due to unexpected expense"
              maxLength={200}
              rows={2}
              className="w-full px-3 py-2 border rounded-md"
            />
          </div>

          <div className="flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border rounded-md hover:bg-gray-50"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={loading}
              className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
            >
              {loading ? 'Saving...' : 'Save Progress'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}
```

Follow patterns:
- TimelineView uses useMemo for performance (like trend-comparison.tsx)
- Table format for "spreadsheet feel" per user requirements
- Color-coded actual vs planned (green if met/exceeded, red if behind)
- ProgressModal uses FormData pattern matching GoalForm
- Fixed overlay modal with backdrop
  </action>
  <verify>
grep "export function TimelineView" src/components/goals/timeline-view.tsx
grep "useMemo.*buildMonthlyTimeline" src/components/goals/timeline-view.tsx
grep "export function ProgressModal" src/components/goals/progress-modal.tsx
grep "upsertGoalProgress" src/components/goals/progress-modal.tsx
  </verify>
  <done>TimelineView renders monthly table with useMemo optimization, shows planned vs actual with color coding. ProgressModal provides form to log monthly progress using FormData pattern.</done>
</task>

<task type="auto">
  <name>Task 4: Create timeline page</name>
  <files>src/app/(dashboard)/goals/timeline/page.tsx</files>
  <action>
Create timeline page loading goals and progress entries:

```typescript
'use client'

import { useEffect, useState } from 'react'
import { getGoals, getGoalProgress } from '@/lib/db'
import { TimelineView } from '@/components/goals/timeline-view'
import type { Goal, ProgressEntry } from '@/types'

export default function TimelinePage() {
  const [goals, setGoals] = useState<Goal[]>([])
  const [progressEntries, setProgressEntries] = useState<ProgressEntry[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    async function load() {
      try {
        setLoading(true)
        const goalsData = await getGoals()
        setGoals(goalsData)

        // Load progress for all goals
        const allProgress: ProgressEntry[] = []
        for (const goal of goalsData) {
          const progress = await getGoalProgress(goal.id)
          allProgress.push(...progress)
        }
        setProgressEntries(allProgress)
      } catch (err) {
        console.error('Failed to load timeline data:', err)
      } finally {
        setLoading(false)
      }
    }
    load()
  }, [])

  if (loading) {
    return (
      <div className="max-w-6xl mx-auto">
        <div className="text-gray-500">Loading timeline...</div>
      </div>
    )
  }

  if (goals.length === 0) {
    return (
      <div className="max-w-6xl mx-auto">
        <h1 className="text-3xl font-bold mb-6">Goal Timeline</h1>
        <div className="text-center py-8 text-gray-500">
          <p className="text-lg font-medium">No goals to display</p>
          <p className="text-sm mt-2">Create financial goals first to see your timeline</p>
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto">
      <div className="mb-6">
        <h1 className="text-3xl font-bold">Goal Timeline</h1>
        <p className="text-gray-600 mt-1">
          Monthly breakdown of savings and goal deadlines
        </p>
      </div>

      <div className="bg-white rounded-lg shadow-sm border p-4">
        <TimelineView goals={goals} progressEntries={progressEntries} />
      </div>
    </div>
  )
}
```

Follow existing page patterns with loading state and empty state handling.
  </action>
  <verify>
cat src/app/(dashboard)/goals/timeline/page.tsx | grep "Goal Timeline"
grep "getGoals()" src/app/(dashboard)/goals/timeline/page.tsx
grep "getGoalProgress" src/app/(dashboard)/goals/timeline/page.tsx
  </verify>
  <done>Timeline page loads goals and progress entries with useEffect, shows TimelineView with monthly table, handles loading and empty states.</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. Verify calculations.ts uses currency.js for all monetary operations
2. Verify status.ts uses TZDate with Asia/Jakarta timezone
3. Verify TimelineView uses useMemo for performance
4. Verify timeline page loads data and handles empty state
5. Verify ProgressModal uses FormData pattern
</verification>

<success_criteria>
- User can view timeline page showing 12 months forward
- Timeline table displays monthly planned vs actual savings
- Goal events appear inline in deadline month
- Actual savings color-coded (green if >= planned, red if behind)
- Goal status infers from deadline and progress (upcoming/in-progress/completed/overdue)
- User override preserved if set
- Timeline risk calculation uses traffic light levels (LOW/MEDIUM/HIGH)
- All calculations use currency.js to prevent floating-point errors
- Date comparisons use Asia/Jakarta timezone
</success_criteria>

<output>
After completion, create `.planning/phases/06-financial-planning-goal-tracking/06-03-SUMMARY.md`
</output>

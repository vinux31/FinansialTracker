---
phase: 06-financial-planning-goal-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/004_create_goals.sql
  - src/lib/supabase/schema.ts
  - src/lib/db.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - User can create financial goals with target amounts and deadlines
    - User's goals are isolated from other users via RLS
    - Goal status auto-infers from deadline and progress data
  artifacts:
    - path: supabase/migrations/004_create_goals.sql
      provides: Goals and progress tables with RLS policies
      contains: "CREATE TABLE goals"
    - path: src/lib/supabase/schema.ts
      provides: Goal validation schemas
      exports: ["CreateGoalSchema", "GOAL_CATEGORIES", "GOAL_PRIORITIES"]
    - path: src/lib/db.ts
      provides: Goal CRUD operations
      exports: ["getGoals", "createGoal", "updateGoal", "deleteGoal"]
  key_links:
    - from: src/lib/db.ts
      to: goals table
      via: Supabase client
      pattern: "supabase\\.from\\('goals'\\)"
---

<objective>
Create database foundation for financial goal tracking with tables, RLS policies, Zod schemas, and CRUD operations.

Purpose: Establish multi-user goal storage matching transactions and investments patterns from Phases 3-4.
Output: PostgreSQL tables, type-safe validation, and authenticated database operations ready for UI integration.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-financial-planning-goal-tracking/06-CONTEXT.md
@.planning/phases/06-financial-planning-goal-tracking/06-RESEARCH.md

Phase 4 established investment tracking pattern - reuse for goals:
@.planning/phases/04-investment-portfolio-tracking/04-01-SUMMARY.md

Current database schema and validation patterns:
@src/lib/supabase/schema.ts
@src/lib/db.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create goals and goal_progress_entries tables with RLS policies</name>
  <files>supabase/migrations/004_create_goals.sql</files>
  <action>
Create PostgreSQL migration following exact pattern from 003_create_investments.sql:

**Goals table:**
- id UUID PRIMARY KEY DEFAULT gen_random_uuid()
- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- name TEXT NOT NULL (1-100 chars for goal name like "Wedding", "House Down Payment")
- category TEXT NOT NULL CHECK (category IN ('Pernikahan', 'Kendaraan', 'Liburan', 'Pendidikan', 'Rumah', 'Dana Darurat', 'Lainnya'))
- target_amount INTEGER NOT NULL CHECK (target_amount > 0) -- IDR target
- deadline DATE NOT NULL -- Goal completion date
- priority TEXT NOT NULL CHECK (priority IN ('High', 'Medium', 'Low'))
- status TEXT NOT NULL CHECK (status IN ('upcoming', 'in-progress', 'completed', 'overdue')) DEFAULT 'upcoming'
- status_override TEXT CHECK (status_override IN ('upcoming', 'in-progress', 'completed', 'overdue', NULL)) -- User manual override
- funding_notes TEXT DEFAULT '' -- Free-form funding source description
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE(user_id, name) -- Prevent duplicate goal names per user

**Goal progress entries table:**
- id UUID PRIMARY KEY DEFAULT gen_random_uuid()
- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- goal_id UUID NOT NULL REFERENCES goals(id) ON DELETE CASCADE
- month TEXT NOT NULL CHECK (month ~ '^\d{4}-\d{2}$') -- YYYY-MM format
- planned_amount INTEGER DEFAULT 0 -- Planned savings this month
- actual_amount INTEGER DEFAULT 0 -- Actual savings this month
- notes TEXT DEFAULT '' -- Variance explanation
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE(user_id, goal_id, month) -- One entry per goal per month

**Indexes (before RLS for performance):**
- CREATE INDEX idx_goals_user_id ON goals(user_id)
- CREATE INDEX idx_goals_category ON goals(category)
- CREATE INDEX idx_goals_deadline ON goals(deadline)
- CREATE INDEX idx_goals_status ON goals(status)
- CREATE INDEX idx_progress_user_id ON goal_progress_entries(user_id)
- CREATE INDEX idx_progress_goal_id ON goal_progress_entries(goal_id)
- CREATE INDEX idx_progress_month ON goal_progress_entries(month)

**RLS policies (4 per table matching Phase 3/4 pattern):**
Goals table:
- SELECT: FOR SELECT USING (auth.uid() = user_id)
- INSERT: FOR INSERT WITH CHECK (auth.uid() = user_id)
- UPDATE: FOR UPDATE USING (auth.uid() = user_id)
- DELETE: FOR DELETE USING (auth.uid() = user_id)

Progress entries table:
- SELECT: FOR SELECT USING (auth.uid() = user_id)
- INSERT: FOR INSERT WITH CHECK (auth.uid() = user_id)
- UPDATE: FOR UPDATE USING (auth.uid() = user_id)
- DELETE: FOR DELETE USING (auth.uid() = user_id)

Follow Phase 4 migration structure: indexes first, then ENABLE ROW LEVEL SECURITY, then CREATE POLICY statements.
  </action>
  <verify>
cat supabase/migrations/004_create_goals.sql | grep "CREATE TABLE goals"
cat supabase/migrations/004_create_goals.sql | grep "CREATE TABLE goal_progress_entries"
cat supabase/migrations/004_create_goals.sql | grep "CREATE INDEX" | wc -l  # Should show 7 indexes
cat supabase/migrations/004_create_goals.sql | grep "CREATE POLICY" | wc -l  # Should show 8 policies
  </verify>
  <done>Migration file exists with goals table (11 columns), progress_entries table (8 columns), 7 indexes, and 8 RLS policies matching Phase 3/4 security pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add goal Zod schemas to schema.ts</name>
  <files>src/lib/supabase/schema.ts</files>
  <action>
Extend schema.ts following DatabaseInvestmentSchema pattern:

**Add goal constants:**
```typescript
export const GOAL_CATEGORIES = ['Pernikahan', 'Kendaraan', 'Liburan', 'Pendidikan', 'Rumah', 'Dana Darurat', 'Lainnya'] as const
export const GOAL_PRIORITIES = ['High', 'Medium', 'Low'] as const
export const GOAL_STATUSES = ['upcoming', 'in-progress', 'completed', 'overdue'] as const
```

**DatabaseGoalSchema** (from database):
- id: z.string().uuid()
- user_id: z.string().uuid()
- name: z.string().min(1).max(100)
- category: z.enum(GOAL_CATEGORIES)
- target_amount: z.number().int().positive()
- deadline: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) -- YYYY-MM-DD
- priority: z.enum(GOAL_PRIORITIES)
- status: z.enum(GOAL_STATUSES)
- status_override: z.enum(GOAL_STATUSES).nullable()
- funding_notes: z.string().default('')
- created_at: z.string().datetime()
- updated_at: z.string().datetime()

**InsertGoalSchema** (before database assigns id/timestamps):
- user_id: z.string().uuid()
- name: z.string().min(1, 'Goal name required').max(100, 'Name too long')
- category: z.enum(GOAL_CATEGORIES, { message: 'Please select a valid category' })
- target_amount: z.number().int().positive('Target amount must be positive')
- deadline: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format').refine(date => new Date(date) > new Date(), 'Deadline must be in the future')
- priority: z.enum(GOAL_PRIORITIES, { message: 'Please select a priority level' })
- funding_notes: z.string().max(500, 'Notes must be under 500 characters').default('')

**UpdateGoalSchema:**
```typescript
export const UpdateGoalSchema = InsertGoalSchema.partial().extend({
  id: z.string().uuid(),
  status_override: z.enum(GOAL_STATUSES).nullable().optional(), // Allow manual status override
})
```

**DatabaseProgressEntrySchema** (from database):
- id: z.string().uuid()
- user_id: z.string().uuid()
- goal_id: z.string().uuid()
- month: z.string().regex(/^\d{4}-\d{2}$/) -- YYYY-MM
- planned_amount: z.number().int().min(0)
- actual_amount: z.number().int().min(0)
- notes: z.string().default('')
- created_at: z.string().datetime()
- updated_at: z.string().datetime()

**InsertProgressEntrySchema:**
- user_id: z.string().uuid()
- goal_id: z.string().uuid()
- month: z.string().regex(/^\d{4}-\d{2}$/, 'Invalid month format (YYYY-MM)')
- planned_amount: z.number().int().min(0, 'Amount cannot be negative')
- actual_amount: z.number().int().min(0, 'Amount cannot be negative')
- notes: z.string().max(200, 'Notes must be under 200 characters').default('')

Export types: DatabaseGoal, InsertGoal, UpdateGoal, DatabaseProgressEntry, InsertProgressEntry
  </action>
  <verify>
grep "export const GOAL_CATEGORIES" src/lib/supabase/schema.ts
grep "DatabaseGoalSchema" src/lib/supabase/schema.ts
grep "InsertGoalSchema" src/lib/supabase/schema.ts
grep "DatabaseProgressEntrySchema" src/lib/supabase/schema.ts
  </verify>
  <done>schema.ts exports goal constants (GOAL_CATEGORIES, GOAL_PRIORITIES, GOAL_STATUSES), DatabaseGoalSchema, InsertGoalSchema, UpdateGoalSchema, DatabaseProgressEntrySchema, InsertProgressEntrySchema with proper validation matching database constraints.</done>
</task>

<task type="auto">
  <name>Task 3: Add goal CRUD operations to db.ts</name>
  <files>src/lib/db.ts, src/types/index.ts</files>
  <action>
**In db.ts:** Add goal operations following getInvestments/createInvestment pattern:

```typescript
// Get all goals for current user
export async function getGoals() {
  const userId = await getUserId()
  const { data, error } = await supabase
    .from('goals')
    .select('*')
    .eq('user_id', userId)
    .order('deadline', { ascending: true }) // Nearest deadline first

  if (error) throw new Error('Failed to load goals')
  return (data || []).map(row => ({
    id: row.id,
    user_id: row.user_id,
    name: row.name,
    category: row.category,
    target_amount: row.target_amount,
    deadline: row.deadline,
    priority: row.priority,
    status: row.status,
    status_override: row.status_override,
    funding_notes: row.funding_notes,
    created_at: row.created_at,
    updated_at: row.updated_at,
  }))
}

// Create a new goal
export async function createGoal(goal: {
  name: string
  category: string
  target_amount: number
  deadline: string
  priority: string
  funding_notes?: string
}) {
  const userId = await getUserId()
  const { data, error } = await supabase
    .from('goals')
    .insert({
      user_id: userId,
      name: goal.name,
      category: goal.category,
      target_amount: goal.target_amount,
      deadline: goal.deadline,
      priority: goal.priority,
      funding_notes: goal.funding_notes || '',
      status: 'upcoming', // Default status
    })
    .select()
    .single()

  if (error) throw new Error('Failed to create goal')
  return data
}

// Update an existing goal
export async function updateGoal(id: string, updates: {
  name?: string
  category?: string
  target_amount?: number
  deadline?: string
  priority?: string
  status_override?: string | null
  funding_notes?: string
}) {
  const userId = await getUserId()

  // Verify ownership first
  const { data: existing, error: fetchError } = await supabase
    .from('goals')
    .select('user_id')
    .eq('id', id)
    .single()

  if (fetchError) throw new Error('Goal not found')
  if (existing.user_id !== userId) throw new Error('Unauthorized: Cannot update goal owned by another user')

  const updateData: Record<string, unknown> = {}
  if (updates.name !== undefined) updateData.name = updates.name
  if (updates.category !== undefined) updateData.category = updates.category
  if (updates.target_amount !== undefined) updateData.target_amount = updates.target_amount
  if (updates.deadline !== undefined) updateData.deadline = updates.deadline
  if (updates.priority !== undefined) updateData.priority = updates.priority
  if (updates.status_override !== undefined) updateData.status_override = updates.status_override
  if (updates.funding_notes !== undefined) updateData.funding_notes = updates.funding_notes
  updateData.updated_at = new Date().toISOString()

  const { data, error } = await supabase
    .from('goals')
    .update(updateData)
    .eq('id', id)
    .select()
    .single()

  if (error) throw new Error('Failed to update goal')
  return data
}

// Delete a goal
export async function deleteGoal(id: string): Promise<void> {
  const userId = await getUserId()

  // Verify ownership first
  const { data: existing, error: fetchError } = await supabase
    .from('goals')
    .select('user_id')
    .eq('id', id)
    .single()

  if (fetchError) throw new Error('Goal not found')
  if (existing.user_id !== userId) throw new Error('Unauthorized: Cannot delete goal owned by another user')

  const { error } = await supabase
    .from('goals')
    .delete()
    .eq('id', id)

  if (error) throw new Error('Failed to delete goal')
}

// Get progress entries for a goal
export async function getGoalProgress(goalId: string) {
  const userId = await getUserId()
  const { data, error } = await supabase
    .from('goal_progress_entries')
    .select('*')
    .eq('user_id', userId)
    .eq('goal_id', goalId)
    .order('month', { ascending: false })

  if (error) throw new Error('Failed to load progress entries')
  return data || []
}

// Create or update progress entry for a goal month
export async function upsertGoalProgress(entry: {
  goal_id: string
  month: string
  planned_amount: number
  actual_amount: number
  notes?: string
}) {
  const userId = await getUserId()
  const { data, error } = await supabase
    .from('goal_progress_entries')
    .upsert({
      user_id: userId,
      goal_id: entry.goal_id,
      month: entry.month,
      planned_amount: entry.planned_amount,
      actual_amount: entry.actual_amount,
      notes: entry.notes || '',
      updated_at: new Date().toISOString(),
    }, {
      onConflict: 'user_id,goal_id,month', // Unique constraint
    })
    .select()
    .single()

  if (error) throw new Error('Failed to save progress entry')
  return data
}
```

**In types/index.ts:** Add Goal and ProgressEntry types:
```typescript
export interface Goal {
  id: string
  user_id: string
  name: string
  category: string
  target_amount: number
  deadline: string // YYYY-MM-DD
  priority: 'High' | 'Medium' | 'Low'
  status: 'upcoming' | 'in-progress' | 'completed' | 'overdue'
  status_override: string | null
  funding_notes: string
  created_at: string
  updated_at: string
}

export interface ProgressEntry {
  id: string
  user_id: string
  goal_id: string
  month: string // YYYY-MM
  planned_amount: number
  actual_amount: number
  notes: string
  created_at: string
  updated_at: string
}
```
  </action>
  <verify>
grep "export async function getGoals" src/lib/db.ts
grep "export async function createGoal" src/lib/db.ts
grep "export async function upsertGoalProgress" src/lib/db.ts
grep "export interface Goal" src/types/index.ts
grep "export interface ProgressEntry" src/types/index.ts
  </verify>
  <done>db.ts exports getGoals, createGoal, updateGoal, deleteGoal, getGoalProgress, upsertGoalProgress with ownership verification. types/index.ts exports Goal and ProgressEntry interfaces.</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. Verify migration file structure matches Phase 3/4 pattern
2. Verify Zod schemas mirror database constraints
3. Verify db.ts CRUD operations match investment pattern with ownership checks
4. Verify types exported in types/index.ts
</verification>

<success_criteria>
- Migration 004 creates goals and goal_progress_entries tables with proper constraints
- 7 indexes exist for query performance (4 on goals, 3 on progress entries)
- 8 RLS policies enforce user isolation (4 per table)
- Zod schemas validate goal creation with category, priority, deadline constraints
- db.ts provides getGoals, createGoal, updateGoal, deleteGoal, getGoalProgress, upsertGoalProgress
- All operations enforce authentication via getUserId()
- Types exported for use in UI components
</success_criteria>

<output>
After completion, create `.planning/phases/06-financial-planning-goal-tracking/06-01-SUMMARY.md`
</output>

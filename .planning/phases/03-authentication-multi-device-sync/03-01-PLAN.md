---
phase: 03-authentication-multi-device-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.local
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/schema.ts
  - supabase/migrations/001_initial_schema.sql
  - supabase/migrations/002_rls_policies.sql
  - middleware.ts
autonomous: false

must_haves:
  truths:
    - "Supabase project exists with connection credentials"
    - "Database has transactions table with user_id column"
    - "Row-Level Security prevents users from seeing others' data"
    - "Token refresh happens automatically on every request"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client factory"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client factory"
      exports: ["createClient"]
    - path: "middleware.ts"
      provides: "Token refresh middleware"
      min_lines: 20
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Database schema with transactions table"
      contains: "CREATE TABLE transactions"
    - path: "supabase/migrations/002_rls_policies.sql"
      provides: "Row-Level Security policies"
      contains: "ALTER TABLE transactions ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "middleware.ts"
      to: "supabase.auth.getUser()"
      via: "token refresh call"
      pattern: "supabase\\.auth\\.getUser\\(\\)"
    - from: "supabase/migrations/002_rls_policies.sql"
      to: "auth.uid()"
      via: "RLS policy user check"
      pattern: "auth\\.uid\\(\\)"

user_setup:
  - service: supabase
    why: "Backend database and authentication provider"
    account_setup:
      - task: "Create free Supabase account"
        url: "https://supabase.com"
      - task: "Create new project with strong database password"
        note: "Save password in password manager - needed for direct DB access"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
    dashboard_config:
      - task: "Confirm email verification is enabled"
        location: "Supabase Dashboard -> Authentication -> Providers -> Email"
        expected: "Enable email provider should be ON"
---

<objective>
Set up Supabase infrastructure with database schema and Row-Level Security policies to enable user authentication and per-user data isolation.

Purpose: Establish the backend foundation for multi-user authentication and secure data storage, replacing localStorage with cloud-based PostgreSQL.

Output: Working Supabase project with transactions table, RLS policies, Supabase client utilities, and middleware for token management.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-multi-device-sync/03-RESEARCH.md

Current codebase context:
@src/types/index.ts
@src/lib/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Install Supabase dependencies</name>
  <files>package.json</files>
  <action>
Install @supabase/supabase-js and @supabase/ssr packages:

```bash
npm install @supabase/supabase-js @supabase/ssr
```

These packages provide:
- @supabase/supabase-js: Core Supabase client SDK for database and auth operations
- @supabase/ssr: Server-side rendering utilities for cookie-based auth (required for Next.js 16)
  </action>
  <verify>package.json includes both @supabase/supabase-js and @supabase/ssr in dependencies</verify>
  <done>Dependencies installed and package.json updated</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Create Supabase project and configure environment variables</action>
  <instructions>
1. Create free Supabase account at https://supabase.com
2. Create new project with region closest to user (Southeast Asia recommended for Indonesia)
3. Save database password in password manager
4. Navigate to Project Settings -> API
5. Copy Project URL and anon public key
6. Create .env.local file in project root with:

```
NEXT_PUBLIC_SUPABASE_URL=https://your-project-ref.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

7. Verify email authentication is enabled:
   - Go to Authentication -> Providers -> Email
   - Confirm "Enable email provider" is ON

IMPORTANT: Do not commit .env.local to git - it's already in .gitignore
  </instructions>
  <resume-signal>Type "configured" when Supabase project is created and .env.local file is ready</resume-signal>
</task>

<task type="auto">
  <name>Create Supabase client utilities</name>
  <files>src/lib/supabase/client.ts, src/lib/supabase/server.ts</files>
  <action>
Create browser and server Supabase client factories following @supabase/ssr pattern from research.

**src/lib/supabase/client.ts** - Browser client:
```typescript
import { createBrowserClient } from '@supabase/ssr'

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
```

**src/lib/supabase/server.ts** - Server client with cookie handling:
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export const createClient = async () => {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Ignore errors in server context (cookies may be read-only)
          }
        },
      },
    }
  )
}
```

Key decisions:
- Use createBrowserClient for client components (browser-side operations)
- Use createServerClient with cookie management for server components and middleware
- Cookie-based sessions prevent XSS token theft (vs localStorage approach)
  </action>
  <verify>Both files exist and export createClient function</verify>
  <done>Supabase client utilities created with cookie-based session management</done>
</task>

<task type="auto">
  <name>Create database schema migration</name>
  <files>supabase/migrations/001_initial_schema.sql</files>
  <action>
Create SQL migration to define transactions table matching existing localStorage Transaction type.

**supabase/migrations/001_initial_schema.sql**:
```sql
-- Create transactions table with user isolation
CREATE TABLE transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('expense', 'income')),
  amount INTEGER NOT NULL CHECK (amount > 0),
  category TEXT NOT NULL,
  notes TEXT NOT NULL DEFAULT '',
  date DATE NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Indexes for performance
  CONSTRAINT valid_expense_category CHECK (
    type = 'income' OR category IN ('Makan', 'Transportasi', 'Rokok', 'Belanja', 'Lainnya')
  ),
  CONSTRAINT valid_income_category CHECK (
    type = 'expense' OR category = 'Income'
  )
);

-- Index on user_id for RLS performance (critical for multi-user queries)
CREATE INDEX transactions_user_id_idx ON transactions(user_id);

-- Index on date for monthly aggregations
CREATE INDEX transactions_date_idx ON transactions(date);

-- Index on timestamp for sorting
CREATE INDEX transactions_timestamp_idx ON transactions(timestamp DESC);

-- Index on user_id + date for combined queries
CREATE INDEX transactions_user_date_idx ON transactions(user_id, date DESC);
```

Schema notes:
- id: UUID instead of string (Supabase default, compatible with crypto.randomUUID() format)
- user_id: References auth.users for data isolation, CASCADE delete ensures cleanup
- amount: INTEGER matches existing pattern (IDR has no cents)
- category: TEXT validates against known categories via CHECK constraints
- date: DATE type for calendar dates (not TIMESTAMPTZ)
- timestamp: TIMESTAMPTZ for precise ordering (includes timezone)
- Indexes on user_id are CRITICAL for RLS performance (prevents full table scans)
  </action>
  <verify>Migration file exists with transactions table definition and all indexes</verify>
  <done>Database schema created with proper types, constraints, and performance indexes</done>
</task>

<task type="auto">
  <name>Create Row-Level Security policies</name>
  <files>supabase/migrations/002_rls_policies.sql</files>
  <action>
Create RLS policies to enforce per-user data isolation at the database level.

**supabase/migrations/002_rls_policies.sql**:
```sql
-- Enable Row-Level Security on transactions table
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view only their own transactions
CREATE POLICY "Users can view their own transactions"
  ON transactions
  FOR SELECT
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
  );

-- Policy: Users can insert only their own transactions
CREATE POLICY "Users can insert their own transactions"
  ON transactions
  FOR INSERT
  TO authenticated
  WITH CHECK (
    (SELECT auth.uid()) = user_id
  );

-- Policy: Users can update only their own transactions
CREATE POLICY "Users can update their own transactions"
  ON transactions
  FOR UPDATE
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
  )
  WITH CHECK (
    (SELECT auth.uid()) = user_id
  );

-- Policy: Users can delete only their own transactions
CREATE POLICY "Users can delete their own transactions"
  ON transactions
  FOR DELETE
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
  );
```

RLS ensures:
- Every query automatically filters by user_id = auth.uid()
- Enforcement at database level (cannot be bypassed by API bugs)
- Anonymous users have NO access (TO authenticated)
- All CRUD operations respect user ownership

CRITICAL: RLS relies on indexes (created in 001_initial_schema.sql). Without user_id index, queries become slow at scale.
  </action>
  <verify>Migration file exists with RLS enabled and all four CRUD policies created</verify>
  <done>Row-Level Security policies enforce per-user data isolation for all operations</done>
</task>

<task type="auto">
  <name>Apply migrations to Supabase project</name>
  <files>supabase/migrations/001_initial_schema.sql, supabase/migrations/002_rls_policies.sql</files>
  <action>
Apply both migration files to the Supabase database using the Supabase SQL Editor.

Steps:
1. Open Supabase Dashboard -> SQL Editor
2. Click "New query"
3. Copy contents of 001_initial_schema.sql and paste into editor
4. Click "Run" to execute
5. Verify success message (no errors)
6. Create another new query
7. Copy contents of 002_rls_policies.sql and paste into editor
8. Click "Run" to execute
9. Verify success message (no errors)
10. Navigate to Table Editor -> transactions to confirm table exists with correct columns

Alternative (if Supabase CLI is preferred):
```bash
# Install Supabase CLI if not already installed
npm install -g supabase

# Login to Supabase
supabase login

# Link to project
supabase link --project-ref your-project-ref

# Apply migrations
supabase db push
```

For this plan, use SQL Editor approach (no CLI setup required).
  </action>
  <verify>Navigate to Supabase Dashboard -> Table Editor and confirm transactions table exists with columns: id, user_id, type, amount, category, notes, date, timestamp, created_at</verify>
  <done>Database schema and RLS policies successfully applied to Supabase project</done>
</task>

<task type="auto">
  <name>Create middleware for token refresh</name>
  <files>middleware.ts</files>
  <action>
Create Next.js middleware to automatically refresh auth tokens on every request, ensuring valid sessions for server components.

**middleware.ts** (at project root):
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: { headers: request.headers },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            response.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // CRITICAL: Use getUser() not getSession() - validates token with Supabase Auth server
  // This prevents spoofed cookie attacks and ensures session is valid
  await supabase.auth.getUser()

  return response
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public assets (png, jpg, jpeg, gif, svg, webp)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:png|jpg|jpeg|gif|svg|webp)$).*)',
  ],
}
```

Why this pattern:
- getUser() makes HTTP request to Supabase Auth, revalidating JWT signature
- Middleware runs on EVERY request before server components load
- Fresh tokens stored in cookies, available to all server components
- Prevents stale/expired token issues without client-side refresh logic
  </action>
  <verify>middleware.ts exists at project root and calls supabase.auth.getUser()</verify>
  <done>Middleware created to automatically refresh auth tokens on every request</done>
</task>

<task type="auto">
  <name>Create Zod schema for database validation</name>
  <files>src/lib/supabase/schema.ts</files>
  <action>
Create Zod schemas for validating data before inserting into Supabase, ensuring type safety during migration.

**src/lib/supabase/schema.ts**:
```typescript
import { z } from 'zod'
import { CATEGORIES } from '@/types'

// Database transaction schema (from Supabase)
export const DatabaseTransactionSchema = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  type: z.enum(['expense', 'income']),
  amount: z.number().int().positive(),
  category: z.enum([...CATEGORIES, 'Income'] as [string, ...string[]]),
  notes: z.string(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD
  timestamp: z.string().datetime(), // ISO 8601 with timezone
  created_at: z.string().datetime(),
})

export type DatabaseTransaction = z.infer<typeof DatabaseTransactionSchema>

// Insert transaction schema (before database assigns id/created_at)
export const InsertTransactionSchema = z.object({
  user_id: z.string().uuid(),
  type: z.enum(['expense', 'income']),
  amount: z.number().int().positive(),
  category: z.enum([...CATEGORIES, 'Income'] as [string, ...string[]]),
  notes: z.string(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  timestamp: z.string().datetime(),
})

export type InsertTransaction = z.infer<typeof InsertTransactionSchema>

// Validate array of transactions (used during migration)
export function validateTransactions(transactions: unknown[]): InsertTransaction[] {
  const result = z.array(InsertTransactionSchema).safeParse(transactions)

  if (!result.success) {
    console.error('Transaction validation errors:', result.error.flatten())
    throw new Error('Invalid transaction data format')
  }

  return result.data
}
```

Usage:
- DatabaseTransactionSchema validates data coming FROM database
- InsertTransactionSchema validates data going TO database
- validateTransactions used during localStorage migration to ensure data integrity
  </action>
  <verify>src/lib/supabase/schema.ts exists and exports DatabaseTransactionSchema, InsertTransactionSchema, and validateTransactions</verify>
  <done>Zod schemas created for database validation with transaction types</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Supabase infrastructure with database schema, Row-Level Security policies, client utilities, middleware, and validation schemas.
  </what-built>
  <how-to-verify>
**1. Verify Supabase project setup:**
- Open Supabase Dashboard (https://supabase.com/dashboard)
- Navigate to Table Editor
- Confirm `transactions` table exists with columns: id, user_id, type, amount, category, notes, date, timestamp, created_at

**2. Verify RLS policies:**
- In Table Editor, click on transactions table
- Click "View Policies" button
- Confirm 4 policies exist: SELECT, INSERT, UPDATE, DELETE (all for authenticated users)

**3. Verify environment variables:**
- Check .env.local exists with NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY
- Run `npm run dev` and confirm no Supabase connection errors in console

**4. Verify files created:**
- src/lib/supabase/client.ts exports createClient
- src/lib/supabase/server.ts exports createClient
- src/lib/supabase/schema.ts exports validation functions
- middleware.ts exists at project root
- supabase/migrations/ directory has both SQL files

**Expected results:**
- No TypeScript errors when running `npm run dev`
- Middleware logs no auth errors in terminal
- All Supabase files follow cookie-based auth pattern (no localStorage usage)
  </how-to-verify>
  <resume-signal>Type "verified" if all checks pass, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
Run these checks to confirm Phase 3 Plan 01 is complete:

1. **Database schema verification:**
   ```sql
   -- Run in Supabase SQL Editor
   SELECT column_name, data_type
   FROM information_schema.columns
   WHERE table_name = 'transactions';
   ```
   Expected: 9 columns (id, user_id, type, amount, category, notes, date, timestamp, created_at)

2. **RLS verification:**
   ```sql
   -- Run in Supabase SQL Editor
   SELECT tablename, policyname, permissive, roles, cmd
   FROM pg_policies
   WHERE tablename = 'transactions';
   ```
   Expected: 4 rows (SELECT, INSERT, UPDATE, DELETE policies)

3. **Index verification:**
   ```sql
   -- Run in Supabase SQL Editor
   SELECT indexname, indexdef
   FROM pg_indexes
   WHERE tablename = 'transactions';
   ```
   Expected: At least 5 indexes including user_id, date, timestamp

4. **TypeScript compilation:**
   ```bash
   npm run build
   ```
   Expected: No type errors

5. **Middleware execution:**
   ```bash
   npm run dev
   # Visit http://localhost:3000
   # Check terminal for middleware logs
   ```
   Expected: No auth errors in terminal
</verification>

<success_criteria>
- Supabase project exists and is accessible via environment variables
- Database has transactions table with proper schema and indexes
- Row-Level Security is enabled with policies for all CRUD operations
- Supabase client utilities (browser and server) are created following @supabase/ssr pattern
- Middleware exists and calls getUser() for token validation
- Zod schemas exist for database validation
- No TypeScript compilation errors
- Project runs without Supabase connection errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-multi-device-sync/03-01-SUMMARY.md`
</output>

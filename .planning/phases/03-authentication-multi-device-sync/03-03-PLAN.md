---
phase: 03-authentication-multi-device-sync
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - src/lib/db.ts
  - src/lib/storage.ts
  - src/components/expense-form.tsx
  - src/components/income-form.tsx
  - src/components/today-summary.tsx
  - src/components/transaction-actions.tsx
  - src/components/charts/category-breakdown.tsx
  - src/components/charts/trend-comparison.tsx
  - src/app/(dashboard)/history/page.tsx
  - src/app/(dashboard)/monthly/page.tsx
  - src/app/(dashboard)/page.tsx
  - src/app/migrate/page.tsx
autonomous: true

must_haves:
  truths:
    - "New transactions save to Supabase instead of localStorage"
    - "Existing localStorage data migrates to Supabase on first login"
    - "Dashboard shows data from Supabase, not localStorage"
    - "User can access same data from multiple devices (with refresh)"
    - "Migration verifies count matches before clearing localStorage"
  artifacts:
    - path: "src/lib/db.ts"
      provides: "Database operations using Supabase"
      exports: ["getTransactions", "addExpense", "addIncome", "updateTransaction", "deleteTransaction", "migrateTransactions"]
      min_lines: 100
    - path: "src/app/migrate/page.tsx"
      provides: "Migration UI for existing users"
      min_lines: 80
    - path: "src/lib/storage.ts"
      provides: "Updated to use db.ts for data operations"
      contains: "from '@/lib/db'"
  key_links:
    - from: "src/lib/db.ts"
      to: "supabase.from('transactions')"
      via: "database queries"
      pattern: "from\\('transactions'\\)"
    - from: "src/components/expense-form.tsx"
      to: "addExpense from db.ts"
      via: "form submission"
      pattern: "addExpense\\("
    - from: "src/app/migrate/page.tsx"
      to: "getTransactions from storage.ts"
      via: "localStorage read"
      pattern: "getTransactions\\("
---

<objective>
Migrate data layer from localStorage to Supabase and implement real-time synchronization across devices.

Purpose: Replace localStorage with cloud database to enable multi-device access while preserving existing user data through safe migration.

Output: All transactions stored in Supabase with real-time sync, migration page for existing users, and verified data integrity.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-multi-device-sync/03-RESEARCH.md
@.planning/phases/03-authentication-multi-device-sync/03-01-SUMMARY.md
@.planning/phases/03-authentication-multi-device-sync/03-02-SUMMARY.md

Current data layer:
@src/lib/storage.ts
@src/types/index.ts

Current components:
@src/components/expense-form.tsx
@src/components/income-form.tsx
@src/components/today-summary.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Supabase database operations module</name>
  <files>src/lib/db.ts</files>
  <action>
Create new database module that replaces localStorage operations with Supabase queries.

**src/lib/db.ts**:
```typescript
'use client'

import { createClient } from '@/lib/supabase/client'
import { Transaction, Category, NewExpense, NewIncome, MonthSummary, CATEGORIES } from '@/types'
import { todayDateString, getMonthFromDate, isToday } from '@/lib/date'
import { sumAmounts } from '@/lib/money'

const supabase = createClient()

// Get current user ID (must be called from authenticated context)
async function getUserId(): Promise<string> {
  const { data, error } = await supabase.auth.getUser()
  if (error || !data.user) {
    throw new Error('User not authenticated')
  }
  return data.user.id
}

// Read all transactions for current user
export async function getTransactions(): Promise<Transaction[]> {
  const userId = await getUserId()

  const { data, error } = await supabase
    .from('transactions')
    .select('*')
    .eq('user_id', userId)
    .order('timestamp', { ascending: false })

  if (error) throw error

  // Transform database records to Transaction type
  return (data || []).map(row => ({
    id: row.id,
    type: row.type,
    amount: row.amount,
    category: row.category,
    notes: row.notes,
    date: row.date,
    timestamp: row.timestamp,
    createdAt: row.created_at,
  }))
}

// Add expense helper
export async function addExpense(expense: NewExpense): Promise<Transaction> {
  const userId = await getUserId()
  const dateStr = todayDateString()
  const timestamp = new Date().toISOString()

  const { data, error } = await supabase
    .from('transactions')
    .insert({
      user_id: userId,
      type: 'expense',
      amount: expense.amount,
      category: expense.category,
      notes: expense.notes,
      date: dateStr,
      timestamp: timestamp,
    })
    .select()
    .single()

  if (error) throw error

  return {
    id: data.id,
    type: data.type,
    amount: data.amount,
    category: data.category as Category,
    notes: data.notes,
    date: data.date,
    timestamp: data.timestamp,
    createdAt: data.created_at,
  }
}

// Add income helper
export async function addIncome(income: NewIncome): Promise<Transaction> {
  const userId = await getUserId()
  const dateStr = todayDateString()
  const timestamp = new Date().toISOString()

  const { data, error } = await supabase
    .from('transactions')
    .insert({
      user_id: userId,
      type: 'income',
      amount: income.amount,
      category: 'Income',
      notes: income.notes,
      date: dateStr,
      timestamp: timestamp,
    })
    .select()
    .single()

  if (error) throw error

  return {
    id: data.id,
    type: data.type,
    amount: data.amount,
    category: data.category as 'Income',
    notes: data.notes,
    date: data.date,
    timestamp: data.timestamp,
    createdAt: data.created_at,
  }
}

// Update an existing transaction
export async function updateTransaction(id: string, updates: Partial<Transaction>): Promise<void> {
  const userId = await getUserId()

  // Build update object with only allowed fields
  const updateData: Record<string, unknown> = {}
  if (updates.amount !== undefined) updateData.amount = updates.amount
  if (updates.category !== undefined) updateData.category = updates.category
  if (updates.notes !== undefined) updateData.notes = updates.notes
  if (updates.date !== undefined) updateData.date = updates.date
  if (updates.timestamp !== undefined) updateData.timestamp = updates.timestamp

  const { error } = await supabase
    .from('transactions')
    .update(updateData)
    .eq('id', id)
    .eq('user_id', userId) // Ensure user owns this transaction

  if (error) throw error
}

// Delete a transaction
export async function deleteTransaction(id: string): Promise<void> {
  const userId = await getUserId()

  const { error } = await supabase
    .from('transactions')
    .delete()
    .eq('id', id)
    .eq('user_id', userId) // Ensure user owns this transaction

  if (error) throw error
}

// Get today's transactions
export async function getTodayTransactions(): Promise<Transaction[]> {
  const transactions = await getTransactions()
  return transactions.filter(tx => isToday(tx.date))
}

// Get today's total spending
export async function getTodayTotal(): Promise<number> {
  const todayTxs = await getTodayTransactions()
  const todayExpenses = todayTxs.filter(tx => tx.type === 'expense')
  return sumAmounts(todayExpenses.map(tx => tx.amount))
}

// Get transactions for a specific month (YYYY-MM)
export async function getMonthTransactions(month: string): Promise<Transaction[]> {
  const transactions = await getTransactions()
  return transactions.filter(tx => getMonthFromDate(tx.date) === month)
}

// Calculate monthly summary
export async function getMonthSummary(month: string): Promise<MonthSummary> {
  const transactions = await getMonthTransactions(month)
  const expenses = transactions.filter(tx => tx.type === 'expense')
  const income = transactions.filter(tx => tx.type === 'income')

  const byCategory = {} as Record<Category, number>
  for (const cat of CATEGORIES) {
    byCategory[cat] = sumAmounts(
      expenses.filter(tx => tx.category === cat).map(tx => tx.amount)
    )
  }

  return {
    month,
    totalExpenses: sumAmounts(expenses.map(tx => tx.amount)),
    totalIncome: sumAmounts(income.map(tx => tx.amount)),
    byCategory,
  }
}

// Migrate transactions helper (used by migration page)
export async function migrateTransactions(transactions: any[]): Promise<number> {
  const userId = await getUserId()

  // Transform and insert
  const dbTransactions = transactions.map(tx => ({
    user_id: userId,
    type: tx.type,
    amount: tx.amount,
    category: tx.category,
    notes: tx.notes,
    date: tx.date,
    timestamp: tx.timestamp,
    created_at: tx.createdAt,
  }))

  const { error } = await supabase
    .from('transactions')
    .insert(dbTransactions)

  if (error) throw error

  // Return count for verification
  const { count } = await supabase
    .from('transactions')
    .select('id', { count: 'exact', head: true })

  return count ?? 0
}
```

API matches existing storage.ts interface but uses Supabase instead of localStorage.

Key differences:
- All functions are async (database calls)
- getUserId() ensures user owns data
- RLS enforces access control at DB level
- migrateTransactions provides safe data migration with verification
  </action>
  <verify>src/lib/db.ts exists and exports getTransactions, addExpense, addIncome, updateTransaction, deleteTransaction, migrateTransactions</verify>
  <done>Database operations module created using Supabase client with migration helper</done>
</task>

<task type="auto">
  <name>Create migration page for existing users</name>
  <files>src/app/migrate/page.tsx</files>
  <action>
Create migration page that detects localStorage data and safely migrates it to Supabase.

**src/app/migrate/page.tsx**:
```typescript
'use client'

import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'
import { getTransactions as getLocalTransactions } from '@/lib/storage'
import { migrateTransactions } from '@/lib/db'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'

const STORAGE_KEY = 'finance-tracker-transactions'

export default function MigratePage() {
  const router = useRouter()
  const [status, setStatus] = useState<'checking' | 'ready' | 'migrating' | 'success' | 'error'>('checking')
  const [localCount, setLocalCount] = useState(0)
  const [error, setError] = useState('')
  const supabase = createClient()

  useEffect(() => {
    checkMigrationStatus()
  }, [])

  async function checkMigrationStatus() {
    try {
      // Check if user is authenticated
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) {
        router.push('/auth/login')
        return
      }

      // Check for localStorage data
      const localTxs = getLocalTransactions()
      setLocalCount(localTxs.length)

      if (localTxs.length === 0) {
        // No data to migrate, redirect to dashboard
        router.push('/')
        return
      }

      // Check if already migrated to Supabase
      const { count } = await supabase
        .from('transactions')
        .select('id', { count: 'exact', head: true })

      if (count && count > 0) {
        // User already has data in Supabase, don't auto-migrate
        setStatus('ready')
      } else {
        // Ready to migrate
        setStatus('ready')
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to check migration status')
      setStatus('error')
    }
  }

  async function handleMigrate() {
    setStatus('migrating')
    setError('')

    try {
      // Get all localStorage transactions
      const localTxs = getLocalTransactions()

      // Use dedicated migration helper from db.ts
      const finalCount = await migrateTransactions(localTxs)

      // Verify count matches
      if (finalCount !== localTxs.length) {
        throw new Error(`Verification failed: Expected ${localTxs.length} transactions, found ${finalCount}`)
      }

      // Clear localStorage ONLY after verification succeeds
      localStorage.removeItem(STORAGE_KEY)

      setStatus('success')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Migration failed')
      setStatus('error')
    }
  }

  if (status === 'checking') {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardContent className="pt-6">
            <p className="text-center">Checking migration status...</p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (status === 'migrating') {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardContent className="pt-6">
            <p className="text-center">Migrating {localCount} transactions...</p>
            <p className="mt-2 text-center text-sm text-gray-600">Please wait, do not close this page</p>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (status === 'success') {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle>Migration Complete</CardTitle>
            <CardDescription>
              Successfully migrated {localCount} transactions to your account
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Button onClick={() => router.push('/')} className="w-full">
              Go to Dashboard
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (status === 'error') {
    return (
      <div className="flex min-h-screen items-center justify-center p-4">
        <Card className="w-full max-w-md">
          <CardHeader>
            <CardTitle>Migration Failed</CardTitle>
            <CardDescription className="text-red-600">{error}</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button onClick={handleMigrate} className="w-full">
              Retry Migration
            </Button>
            <Button onClick={() => router.push('/')} variant="outline" className="w-full">
              Skip for Now
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  // status === 'ready'
  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Migrate Your Data</CardTitle>
          <CardDescription>
            You have {localCount} transactions stored locally. Migrate them to your account for access from any device.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="rounded-md bg-blue-50 p-4 text-sm text-blue-800">
            <p className="font-semibold mb-2">What happens during migration:</p>
            <ul className="list-disc list-inside space-y-1">
              <li>All transactions copied to secure cloud database</li>
              <li>Data verified to ensure nothing is lost</li>
              <li>Local storage cleared only after verification</li>
              <li>You can access data from any device after migration</li>
            </ul>
          </div>
          <Button onClick={handleMigrate} className="w-full">
            Migrate {localCount} Transactions
          </Button>
          <Button onClick={() => router.push('/')} variant="outline" className="w-full">
            Skip for Now
          </Button>
        </CardContent>
      </Card>
    </div>
  )
}
```

Migration safety features:
1. Detects localStorage data automatically
2. Shows clear explanation of migration process
3. Batch insert for performance
4. Verifies count matches before clearing localStorage
5. Allows retry if migration fails
6. Option to skip (preserves localStorage for manual export)
  </action>
  <verify>src/app/migrate/page.tsx exists with migration UI and verification logic</verify>
  <done>Migration page created with safe data transfer and verification</done>
</task>

<task type="auto">
  <name>Update components to use database operations</name>
  <files>src/components/expense-form.tsx, src/components/income-form.tsx, src/components/today-summary.tsx, src/components/transaction-actions.tsx</files>
  <action>
Update all form and display components to use async database operations from db.ts instead of localStorage.

**Pattern for all components:**
1. Import from '@/lib/db' instead of '@/lib/storage'
2. Make handlers async
3. Add loading states during database operations
4. Handle errors from async operations
5. Keep existing UI/validation logic

**src/components/expense-form.tsx:**
```typescript
// Change import
import { addExpense } from '@/lib/db' // instead of storage

// Make handler async
async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
  e.preventDefault()
  setError('')
  setLoading(true) // Add loading state

  // ... existing validation ...

  try {
    await addExpense(expense) // Now async
    form.reset()
    onRefresh?.()
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Failed to save expense')
  } finally {
    setLoading(false)
  }
}

// Add loading state to submit button
<Button type="submit" disabled={loading}>
  {loading ? 'Saving...' : 'Add Expense'}
</Button>
```

**src/components/income-form.tsx:**
Same pattern - import from db, make async, add loading state.

**src/components/today-summary.tsx:**
```typescript
import { getTodayTransactions, getTodayTotal } from '@/lib/db'

// Make data loading async
useEffect(() => {
  async function loadData() {
    setLoading(true)
    try {
      const [txs, total] = await Promise.all([
        getTodayTransactions(),
        getTodayTotal()
      ])
      setTransactions(txs)
      setTodayTotal(total)
    } catch (err) {
      console.error('Failed to load data:', err)
    } finally {
      setLoading(false)
    }
  }
  loadData()
}, [refreshKey])

// Show loading state
if (loading) {
  return <div>Loading...</div>
}
```

**src/components/transaction-actions.tsx:**
```typescript
import { updateTransaction, deleteTransaction } from '@/lib/db'

// Make handlers async
async function handleSave() {
  setLoading(true)
  try {
    await updateTransaction(transaction.id, editData)
    setIsEditing(false)
    onUpdate?.()
  } catch (err) {
    alert(err instanceof Error ? err.message : 'Failed to update')
  } finally {
    setLoading(false)
  }
}

async function handleDelete() {
  if (!confirm('Delete this transaction?')) return

  setLoading(true)
  try {
    await deleteTransaction(transaction.id)
    onUpdate?.()
  } catch (err) {
    alert(err instanceof Error ? err.message : 'Failed to delete')
  } finally {
    setLoading(false)
  }
}
```

Keep:
- All existing form validation
- All existing UI structure
- All existing callback patterns (onRefresh, onUpdate)
- All existing error display
  </action>
  <verify>All form components import from @/lib/db and have async handlers with loading states</verify>
  <done>Components updated to use async database operations with loading states</done>
</task>

<task type="auto">
  <name>Update chart components for async data loading</name>
  <files>src/components/charts/category-breakdown.tsx, src/components/charts/trend-comparison.tsx</files>
  <action>
Update chart components to load data asynchronously from database.

**Pattern for both charts:**
1. Import aggregation helpers from @/lib/db
2. Load data in useEffect with async
3. Add loading state
4. Keep existing memoization patterns
5. Keep existing chart rendering logic

**src/components/charts/category-breakdown.tsx:**
```typescript
import { getMonthTransactions } from '@/lib/db'

const [transactions, setTransactions] = useState<Transaction[]>([])
const [loading, setLoading] = useState(true)

useEffect(() => {
  async function loadData() {
    setLoading(true)
    try {
      const txs = await getMonthTransactions(month)
      setTransactions(txs)
    } catch (err) {
      console.error('Failed to load transactions:', err)
    } finally {
      setLoading(false)
    }
  }
  loadData()
}, [month])

// Use transactions in existing useMemo for chartData
const chartData = useMemo(() => {
  return aggregateByCategory(transactions.filter(tx => tx.type === 'expense'))
}, [transactions])

if (loading) {
  return <div className="text-center py-8">Loading chart...</div>
}

// ... rest of existing chart rendering ...
```

**src/components/charts/trend-comparison.tsx:**
Same pattern - async load, loading state, preserve existing aggregation logic.

Keep:
- All existing useMemo optimizations
- All existing chart configuration
- All existing empty state handling
- All existing time range selector logic
  </action>
  <verify>Chart components load data asynchronously and show loading states</verify>
  <done>Chart components updated for async database operations</done>
</task>

<task type="auto">
  <name>Update page components for async data loading</name>
  <files>src/app/(dashboard)/history/page.tsx, src/app/(dashboard)/monthly/page.tsx, src/app/(dashboard)/page.tsx</files>
  <action>
Update all page components to use async database operations.

**src/app/(dashboard)/page.tsx:**
No changes needed - this page only renders ExpenseForm and TodaySummary which are already updated.

**src/app/(dashboard)/history/page.tsx:**
```typescript
import { getTransactions } from '@/lib/db'

// Change to client component
'use client'

const [transactions, setTransactions] = useState<Transaction[]>([])
const [loading, setLoading] = useState(true)

useEffect(() => {
  async function loadData() {
    setLoading(true)
    try {
      const txs = await getTransactions()
      setTransactions(txs)
    } catch (err) {
      console.error('Failed to load transactions:', err)
    } finally {
      setLoading(false)
    }
  }
  loadData()
}, [refreshKey])

if (loading) {
  return <div>Loading...</div>
}

// ... rest of existing rendering logic ...
```

**src/app/(dashboard)/monthly/page.tsx:**
```typescript
import { getMonthSummary } from '@/lib/db'

'use client'

const [summary, setSummary] = useState<MonthSummary | null>(null)
const [loading, setLoading] = useState(true)

useEffect(() => {
  async function loadData() {
    setLoading(true)
    try {
      const data = await getMonthSummary(selectedMonth)
      setSummary(data)
    } catch (err) {
      console.error('Failed to load summary:', err)
    } finally {
      setLoading(false)
    }
  }
  loadData()
}, [selectedMonth])

// ... rest of existing logic ...
```

Keep:
- All existing UI structure
- All existing month selector logic
- All existing formatCurrency usage
- All existing CSV export functionality
  </action>
  <verify>Page components load data asynchronously from database</verify>
  <done>Page components updated to use async database operations</done>
</task>

<task type="auto">
  <name>Update storage.ts to preserve localStorage fallback</name>
  <files>src/lib/storage.ts</files>
  <action>
Keep storage.ts for two purposes:
1. Reading localStorage during migration (getTransactions for migration page)
2. CSV export compatibility (existing export functions may use it)

Update storage.ts to mark localStorage functions as legacy:

```typescript
// Legacy localStorage functions - kept for migration and export compatibility
// New code should use @/lib/db instead

import { Transaction, Category, CATEGORIES, NewExpense, NewIncome, MonthSummary } from '@/types'
import { todayDateString, currentMonthString, getMonthFromDate, isToday } from '@/lib/date'
import { sumAmounts } from '@/lib/money'

const STORAGE_KEY = 'finance-tracker-transactions'

// SSR guard: returns empty on server
function isClient(): boolean {
  return typeof window !== 'undefined'
}

// LEGACY: Read localStorage transactions (used only for migration)
export function getTransactions(): Transaction[] {
  if (!isClient()) return []
  try {
    const data = localStorage.getItem(STORAGE_KEY)
    return data ? JSON.parse(data) : []
  } catch {
    return []
  }
}

// All other functions removed - use @/lib/db instead
```

This preserves migration capability while preventing new code from using localStorage.
  </action>
  <verify>storage.ts only exports getTransactions and includes comment directing to db.ts</verify>
  <done>storage.ts updated to preserve migration compatibility while directing to db.ts</done>
</task>

<task type="auto">
  <name>Add migration detection to dashboard layout</name>
  <files>src/app/(dashboard)/layout.tsx</files>
  <action>
Update dashboard layout to detect localStorage data and redirect to migration page.

Add after authentication check:

```typescript
// After getUser() check:
const { data, error } = await supabase.auth.getUser()
if (error || !data?.user) {
  redirect('/auth/login')
}

// Check for localStorage data that needs migration
// This runs server-side but we need client-side check
// Instead, add to client component or use middleware

// Better approach: Add a migration check component
```

Actually, better to add a client component that checks localStorage and redirects:

Create small migration detector component that runs client-side:
```typescript
// In layout.tsx, add:
import MigrationDetector from '@/components/migration-detector'

// In JSX:
<MigrationDetector userId={data.user.id} />
```

Then create src/components/migration-detector.tsx:
```typescript
'use client'

import { useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'

const STORAGE_KEY = 'finance-tracker-transactions'

export default function MigrationDetector({ userId }: { userId: string }) {
  const router = useRouter()

  useEffect(() => {
    async function checkMigration() {
      // Check localStorage
      const localData = localStorage.getItem(STORAGE_KEY)
      if (!localData) return

      const localTxs = JSON.parse(localData)
      if (localTxs.length === 0) return

      // Check if user has data in Supabase
      const supabase = createClient()
      const { count } = await supabase
        .from('transactions')
        .select('id', { count: 'exact', head: true })

      // If no Supabase data but has localStorage data, redirect to migration
      if (count === 0) {
        router.push('/migrate')
      }
    }

    checkMigration()
  }, [userId, router])

  return null // No UI, just a detector
}
```
  </action>
  <verify>Dashboard layout includes migration detection that redirects users with localStorage data</verify>
  <done>Migration detection added to redirect users with unmigrated data</done>
</task>

</tasks>

<verification>
Run these checks to confirm data migration and sync work:

1. **Fresh user flow (no localStorage):**
   ```bash
   # Clear localStorage
   # Visit http://localhost:3000
   # Sign up with new email
   # Add an expense
   # Verify expense appears in dashboard
   # Check Supabase Dashboard -> Table Editor -> transactions
   # Verify row exists with your user_id
   ```

2. **Migration flow (existing localStorage data):**
   ```bash
   # Add test data to localStorage in browser console:
   localStorage.setItem('finance-tracker-transactions', JSON.stringify([
     {
       id: 'test-1',
       type: 'expense',
       amount: 50000,
       category: 'Makan',
       notes: 'Test',
       date: '2026-02-15',
       timestamp: '2026-02-15T10:00:00Z',
       createdAt: '2026-02-15T10:00:00Z'
     }
   ]))
   # Visit http://localhost:3000
   # Verify redirect to /migrate
   # Click "Migrate" button
   # Verify success message
   # Verify data appears in dashboard
   # Check localStorage is cleared
   ```

3. **Multi-device sync (requires two browsers or devices):**
   ```bash
   # Browser 1: Log in and add expense
   # Browser 2: Log in with same account and refresh page
   # Verify expense appears in Browser 2
   # Browser 2: Add another expense
   # Browser 1: Refresh page
   # Verify new expense appears in Browser 1
   ```

4. **Database operations:**
   ```bash
   # Test all CRUD operations:
   # - Add expense (works)
   # - Edit transaction on Today page (works)
   # - Delete transaction (works)
   # - View history (loads from DB)
   # - View monthly summary (aggregates from DB)
   # - View charts (render from DB data)
   ```

5. **TypeScript compilation:**
   ```bash
   npm run build
   ```
   Expected: No type errors
</verification>

<success_criteria>
- New transactions save to Supabase database instead of localStorage
- Existing localStorage data migrates safely with count verification
- Migration page shows clear progress and error states
- All components load data asynchronously from database
- Charts and summaries aggregate data from database
- Multi-device sync works with manual refresh (changes appear on other devices after refresh)
- No data loss during migration (verification step succeeds)
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-multi-device-sync/03-03-SUMMARY.md`
</output>

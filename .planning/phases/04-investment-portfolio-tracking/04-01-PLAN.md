---
phase: 04-investment-portfolio-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/003_create_investments.sql
  - src/lib/supabase/schema.ts
  - src/lib/db.ts
autonomous: true

must_haves:
  truths:
    - "Database can store investment records with user isolation"
    - "Investment data validates category constraints at database level"
    - "Investment queries are indexed for performance"
  artifacts:
    - path: "supabase/migrations/003_create_investments.sql"
      provides: "Investments table with RLS policies"
      contains: "CREATE TABLE investments"
    - path: "src/lib/supabase/schema.ts"
      provides: "Investment validation schemas"
      exports: ["DatabaseInvestmentSchema", "InsertInvestmentSchema", "UpdateInvestmentSchema"]
    - path: "src/lib/db.ts"
      provides: "Investment CRUD operations"
      exports: ["getInvestments", "createInvestment", "updateInvestment", "deleteInvestment"]
  key_links:
    - from: "src/lib/db.ts"
      to: "investments table"
      via: "Supabase select/insert/update/delete"
      pattern: "supabase\\.from\\('investments'\\)"
    - from: "src/lib/supabase/schema.ts"
      to: "database constraints"
      via: "Zod enum matching database CHECK"
      pattern: "z\\.enum\\(\\['Saham', 'Emas', 'Reksadana'\\]\\)"
---

<objective>
Create PostgreSQL investments table with Row-Level Security, validation schemas, and database operations module.

Purpose: Establish database foundation for investment tracking, reusing proven RLS patterns from transactions table.
Output: Migration file, Zod schemas, and db.ts functions for investment CRUD operations.
</objective>

<execution_context>
@C:/Users/rinoa/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rinoa/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-investment-portfolio-tracking/04-RESEARCH.md

# Prior phase patterns
@.planning/phases/03-authentication-multi-device-sync/03-01-SUMMARY.md

# Current schema
@src/lib/supabase/schema.ts
@src/lib/db.ts
</context>

<tasks>

<task type="auto">
  <name>Create investments table migration with RLS policies</name>
  <files>supabase/migrations/003_create_investments.sql</files>
  <action>
Create SQL migration file following the exact pattern from 001_initial_schema.sql and 002_rls_policies.sql.

**Table structure:**
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- user_id: UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- name: TEXT NOT NULL (investment name like "Apple Stock")
- category: TEXT NOT NULL (Saham, Emas, or Reksadana)
- monthly_contribution: INTEGER NOT NULL CHECK (monthly_contribution > 0) (in IDR, no decimals)
- current_value: INTEGER NOT NULL CHECK (current_value > 0) (in IDR, no decimals)
- purchase_date: DATE NOT NULL
- notes: TEXT NOT NULL DEFAULT ''
- timestamp: TIMESTAMPTZ NOT NULL
- created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
- updated_at: TIMESTAMPTZ NOT NULL DEFAULT now()

**Constraints:**
- CHECK constraint: category IN ('Saham', 'Emas', 'Reksadana')

**Indexes (create BEFORE RLS per Phase 3 decision):**
- investments_user_id_idx ON investments(user_id)
- investments_category_idx ON investments(category)
- investments_user_category_idx ON investments(user_id, category)
- investments_user_id_created_at_idx ON investments(user_id, created_at DESC)

**RLS policies (exactly 4 like transactions):**
1. "Users can view their own investments" - SELECT policy with USING ((SELECT auth.uid()) = user_id)
2. "Users can insert their own investments" - INSERT policy with WITH CHECK ((SELECT auth.uid()) = user_id)
3. "Users can update their own investments" - UPDATE policy with USING and WITH CHECK
4. "Users can delete their own investments" - DELETE policy with USING ((SELECT auth.uid()) = user_id)

Enable RLS: ALTER TABLE investments ENABLE ROW LEVEL SECURITY;

Follow exact syntax from 001/002 migrations. Use TIMESTAMPTZ for timestamp fields, DATE for purchase_date.
  </action>
  <verify>
```bash
# Check migration file exists and has correct structure
grep -q "CREATE TABLE investments" supabase/migrations/003_create_investments.sql
grep -q "ENABLE ROW LEVEL SECURITY" supabase/migrations/003_create_investments.sql
grep -q "CREATE POLICY" supabase/migrations/003_create_investments.sql | wc -l  # Should show 4
```
  </verify>
  <done>Migration file exists with investments table, 4 indexes, CHECK constraint for categories, and 4 RLS policies (SELECT, INSERT, UPDATE, DELETE)</done>
</task>

<task type="auto">
  <name>Add investment Zod schemas to schema.ts</name>
  <files>src/lib/supabase/schema.ts</files>
  <action>
Extend existing schema.ts file following the exact pattern used for DatabaseTransactionSchema and InsertTransactionSchema.

**Add constant:**
```typescript
export const INVESTMENT_CATEGORIES = ['Saham', 'Emas', 'Reksadana'] as const
```

**Add schemas (mirror transaction pattern):**

1. DatabaseInvestmentSchema - Full record from database:
   - id: z.string().uuid()
   - user_id: z.string().uuid()
   - name: z.string().min(1).max(255)
   - category: z.enum(INVESTMENT_CATEGORIES)
   - monthly_contribution: z.number().int().positive()
   - current_value: z.number().int().positive()
   - purchase_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/)
   - notes: z.string().default('')
   - timestamp: z.string().datetime()
   - created_at: z.string().datetime()
   - updated_at: z.string().datetime()

2. InsertInvestmentSchema - For creating new investments:
   - Same as DatabaseInvestmentSchema but without id, created_at, updated_at
   - Add error messages: name.min('Investment name required'), category errorMap for invalid category, monthly_contribution.positive('Contribution must be positive')

3. UpdateInvestmentSchema - For updates:
   - InsertInvestmentSchema.partial().extend({ id: z.string().uuid() })

**Add types:**
```typescript
export type DatabaseInvestment = z.infer<typeof DatabaseInvestmentSchema>
export type InsertInvestment = z.infer<typeof InsertInvestmentSchema>
export type UpdateInvestment = z.infer<typeof UpdateInvestmentSchema>
```

**Add validation helper (mirror validateTransactions pattern):**
```typescript
export function validateInvestments(investments: unknown[]): InsertInvestment[] {
  const result = z.array(InsertInvestmentSchema).safeParse(investments)
  if (!result.success) {
    console.error('Investment validation errors:', result.error.flatten())
    throw new Error('Invalid investment data format')
  }
  return result.data
}
```

Use existing import statements. All integers for IDR amounts (no decimals). Match database constraints exactly.
  </action>
  <verify>
```bash
# Check schemas exist in file
grep -q "DatabaseInvestmentSchema" src/lib/supabase/schema.ts
grep -q "InsertInvestmentSchema" src/lib/supabase/schema.ts
grep -q "UpdateInvestmentSchema" src/lib/supabase/schema.ts
grep -q "INVESTMENT_CATEGORIES" src/lib/supabase/schema.ts
```
  </verify>
  <done>schema.ts exports INVESTMENT_CATEGORIES constant, three investment schemas (Database, Insert, Update), corresponding types, and validateInvestments helper function</done>
</task>

<task type="auto">
  <name>Add investment database operations to db.ts</name>
  <files>src/lib/db.ts</files>
  <action>
Extend existing db.ts file with investment CRUD operations, following exact pattern from transaction functions (getTransactions, createTransaction, etc).

**Add four functions:**

1. getInvestments() - async function
   - Call getUserId() for authentication (existing pattern)
   - Query: supabase.from('investments').select('*').eq('user_id', userId).order('created_at', { ascending: false })
   - Validate response with DatabaseInvestmentSchema array
   - Return DatabaseInvestment[] or throw error with message

2. createInvestment(investment: InsertInvestment) - async function
   - Call getUserId()
   - Validate with InsertInvestmentSchema.safeParse()
   - Insert: supabase.from('investments').insert([validatedData]).select().single()
   - Validate response with DatabaseInvestmentSchema
   - Return created investment or throw error

3. updateInvestment(id: string, updates: Partial&lt;InsertInvestment&gt;) - async function
   - Call getUserId()
   - First verify ownership: SELECT user_id WHERE id = id
   - Check userId matches (throw 'Unauthorized' if not)
   - Update: supabase.from('investments').update(updates).eq('id', id).select().single()
   - Validate with DatabaseInvestmentSchema
   - Return updated investment or throw error

4. deleteInvestment(id: string) - async function
   - Call getUserId()
   - Verify ownership first (same pattern as update)
   - Delete: supabase.from('investments').delete().eq('id', id)
   - Check for error
   - Return void or throw error

**Error handling:** Use same try/catch pattern as transaction functions. Log errors with console.error. Throw descriptive messages.

Import types from @/lib/supabase/schema. Use existing createBrowserClient pattern. Follow async/await conventions from existing functions.
  </action>
  <verify>
```bash
# Check all four functions exist
grep -q "export async function getInvestments" src/lib/db.ts
grep -q "export async function createInvestment" src/lib/db.ts
grep -q "export async function updateInvestment" src/lib/db.ts
grep -q "export async function deleteInvestment" src/lib/db.ts
```
  </verify>
  <done>db.ts exports four investment functions (getInvestments, createInvestment, updateInvestment, deleteInvestment) with authentication checks, validation, and error handling matching transaction function patterns</done>
</task>

</tasks>

<verification>
**Database foundation complete when:**
1. Migration file exists with proper structure and can be applied to Supabase
2. Zod schemas compile without errors and match database constraints
3. db.ts investment functions mirror transaction function patterns
4. All files follow existing code style and import conventions
</verification>

<success_criteria>
- Migration file creates investments table with user_id foreign key, category CHECK constraint, 4 indexes, and 4 RLS policies
- Zod schemas validate investment data with proper error messages
- db.ts functions provide type-safe CRUD operations with authentication checks
- Code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-investment-portfolio-tracking/04-01-SUMMARY.md`
</output>
